#include <Servo.h>
#include <LoRa.h>
#include <SPI.h>

// Оголошення об'єкта для керування сервомотором - у нашому випадку безколекторним мотором,
// підключеним через спеціалізований модуль керування безколекторними моторами TSKY 120A.
// Цей модуль приймає сигнали керування, подібні до тих, що використовуються для звичайних
// сервоприводів (зазвичай ШІМ - широтно-імпульсна модуляція), і забезпечує необхідні
// фазування та потужність для обертання безколекторного двигуна. Для генерації таких
// ШІМ-сигналів може використовуватися бібліотека Servo в Arduino або аналогічні
// функції в інших мікроконтролерних платформах.
Servo motor;

int 
val, // Змінна для конвертування значення швидкості 
packetSize,  // Довжина пакету даних, який отримується модулем LoRa чи Bluetooth 
com, // Код команди
sp1, // Допоміжна змінна для конвертації швидкості обертання мотору
r, // Режим роботи системи
ss, // Проміжна швидкість при розгоні/сповільненні обертання мотору
sp; // Швидкість обертання мотору

unsigned long 
ts1, // Час отримання останньої команди
tms,  
hl, // Час початку кроку для інтервального режиму руху
hlm, // Час руху в мілісекундах для інтервального режиму руху
hld, // Час зупинки в мілісекундах для інтервального режиму руху
tsp; // Змінна для зберігання інтервалів часу при розгоні/сповільненні мотору 

bool 
mo, // Прапорець режимів: постійного руху (true) або руху (false), який активується натисканням кнопки на пульті
ls; // Напрям руху вперед (true) / назад (false)
 
String s; // Рядок даних від модуля LoRa
String inputString = ""; // Рядок даних від Bluetooth модуля
bool stringComplete = false;  // Прапорець фіксує, що повне повідомлення було отримано і готове до подальшої обробки

// Мигаємо світлодіодом на платі один раз
void blink() {
  digitalWrite(PC13, HIGH);   // Встановлюємо високий рівень на виводі PC13, щоб увімкнути світлодіод
  delay(400);                // Затримуємо виконання програми на 400 мілісекунд
  digitalWrite(PC13, LOW);    // Встановлюємо низький рівень на виводі PC13, щоб вимкнути світлодіод
  delay(400);                // Знову затримуємо виконання програми на 400 мілісекунд
}

// Калібрування мотора
void calibr_motor() {
  blink();        // Мигаємо світлодіодом 1 раз, щоб сигналізувати початок калібрування
  // Задаємо мотору нейтральне положення (зазвичай 90 градусів для сервоприводів)
  motor.write(90);
  delay(1000);    // Чекаємо 1 секунду, щоб мотор встиг перейти в нейтральне положення
  blink();
  blink();        // Мигаємо світлодіодом 2 рази, сигналізуючи перехід до наступного етапу
  // Задаємо положення "вперед" (зазвичай 180 градусів для сервоприводів)
  motor.write(180);
  delay(1000);    // Чекаємо 1 секунду, щоб мотор перейшов у положення "вперед"
  blink();
  blink();
  blink();        // Мигаємо світлодіодом 3 рази, сигналізуючи перехід до наступного етапу
  // Задаємо мотору положення "назад" (зазвичай 0 градусів для сервоприводів)
  motor.write(0);
  delay(1000);    // Чекаємо 1 секунду, щоб мотор перейшов у положення "назад"
  // Повертаємо мотор у нейтральне положення після завершення калібрування
  motor.write(90);
}

// Конвертація частини рядка (позиція, кількість символів) повідомлення в числові дані команди
int stod(int po, int co) {
  int cd = 0; // Ініціалізація змінної для зберігання числового значення команди
  // Цикл для ітерації по символах підстроки, крім останнього
  for (int j = 0; j < co - 1; j++) {
    // Отримання числового значення символу (віднімання ASCII коду '0')
    // та додавання його до 'cd' з урахуванням його розряду
    cd += (s.charAt(j + po) - 48) * pow(10, co - j - 1);
  }
  // Додавання числового значення останнього символу підстроки до 'cd'
  return cd + (s.charAt(po + co - 1) - 48);
}

void setup() {
  sp = 90; // Початкове значення швидкості системи = 0 (нейтральне положення для сервоприводу)
  // Налаштування пінів для кінцевих вимикачів з внутрішнім підтягуванням до VCC
  pinMode(PA0, INPUT_PULLUP);
  pinMode(PA1, INPUT_PULLUP);
  // Налаштування піна PB4 як входу (без підтягування)
  pinMode(PB4, INPUT);
  // Налаштування піна PB12 як виходу 
  pinMode(PB12, OUTPUT);
  // Встановлення початкового низького рівня на піні PB12
  digitalWrite(PB12, LOW);

  // Ініціалізація піна керування мотором (сервоприводом)
  // motor.attach(пін, мінімальна_тривалість_імпульсу_в_мкс, максимальна_тривалість_імпульсу_в_мкс)
  motor.attach(PB7, 1000, 2000);
  // calibr_motor(); // Виклик функції калібрування мотора
  // Задаємо мотору початкове нейтральне положення
  motor.write(sp);
  // Налаштування піна PC13 як виходу для керування вбудованим світлодіодом
  pinMode(PC13, OUTPUT);
  // Ініціалізація послідовного порту для налагодження
  Serial.begin(115200);
  // Ініціалізація другого послідовного порту (Serial1) для зв'язку з bluetooth
  Serial1.begin(115200);

  // Ініціалізація бібліотеки для модуля SX1278 (LoRa)
  // LoRa.setPins(SS, RST, DIO0)
  LoRa.setPins(PA4, PC15, PC14);
  // Запуск LoRa з вказаною частотою (433 МГц)
  if (!LoRa.begin(433E6)) {
    Serial.println("Помилка ініціалізації LoRa!");
  }
  // Увімкнення перевірки контрольної суми (CRC) для LoRa пакетів
  LoRa.enableCrc();
  // Перехід LoRa модуля в режим прийому
  LoRa.receive();

  r = 0;      // Встановлюємо режим роботи системи в початкове значення (0)
  mo = false; // Скидаємо логічний прапорець режиму постійного руху в 'false' (вимкнено)
  ls = false; // Скидаємо логічний прапорець напрямку руху в 'false' (за замовчуванням - назад або зупинка)
  com = 0;    // Скидаємо змінну для зберігання команди в початкове значення (0 - немає команди)
  hld = 0;    // Скидаємо змінну для зберігання деякого значення (часу зупинки в інтервальному режимі) в початкове значення (0)
  sp1 = 20;   // Встановлюємо початкове значення швидкості (яке потім може бути змінене) в 20
  tsp = 0;    // Скидаємо змінну для зберігання інтервалів часу при розгоні/сповільненні мотору в початкове значення (0)
}

void loop() {
 
// Зміна напряму руху системи на кінці тросу за допомогою кінцевого вимикача
if (ls) // Перевіряємо напрямок руху: true - вперед, false - назад
{
  // Якщо візок рухається вперед (ls == true)
  if (digitalRead(PA1) == LOW) // Перевіряємо стан кінцевого вимикача PA1. LOW означає, що він натиснутий
  {
    ss = motor.read(); // Зчитуємо поточне положення (швидкість) мотора
    // Якщо поточна швидкість більше за нейтральну (90), візок рухається вперед
    if (ss > 90)
    {
      tsp = millis(); // Запам'ятовуємо поточний час для подальшого використання (зміни напряму)
      sp = 90 - abs(ss - 90); // Обчислюємо нову швидкість для зміни напряму руху
      motor.write(75); // Записуємо нову, меншу швидкість для руху назад
      // Якщо система в інтервальному режимі (r == 2) і була команда "назад" (com == 4),
      // змінюємо команду на "вперед" (com == 3), щоб відобразити зміну напрямку після спрацювання кінцевика
      if (r == 2 && com == 4) com = 3;
    }
  } else
  // Якщо візок рухається назад (ls == false)
  if (digitalRead(PA0) == LOW) // Перевіряємо стан кінцевого вимикача PA0. LOW означає, що він натиснутий
  {
    ss = motor.read(); // Зчитуємо поточне положення (швидкість) мотора
    // Якщо поточна швидкість менше за нейтральну (90), візок рухається назад
    if (ss < 90)
    {
      tsp = millis(); // Запам'ятовуємо поточний час для подальшого використання (зміни напряму)
      sp = 90 + abs(90 - ss); // Обчислюємо нову швидкість для зміни напряму руху
      motor.write(105); // Записуємо нову, більшу швидкість для руху вперед
      // Якщо система в інтервальному режимі (r == 2) і була команда "вперед" (com == 3),
      // змінюємо команду на "назад" (com == 4), щоб відобразити зміну напрямку після спрацювання кінцевика
      if (r == 2 && com == 3) com = 4;
    }
  }
}

  // Отримуємо поточне значення швидкості обертання мотора
ss = motor.read();

// Плавний розгін мотора, якщо поточна швидкість менша за задану
if (ss < sp && millis() - tsp >= 50)
{
  tsp = millis(); // Оновлюємо час останньої зміни швидкості
  ss += 5;       // Збільшуємо поточну швидкість на невелике значення для плавного розгону
  // Якщо досягли або перевищили задану швидкість, встановлюємо точне задане значення
  if (ss >= sp)
    motor.write(sp);
  else
    // Інакше, записуємо проміжне значення швидкості
    motor.write(ss);
} else
// Плавне сповільнення мотора, якщо поточна швидкість більша за задану
if (ss > sp && millis() - tsp >= 50)
{
  tsp = millis(); // Оновлюємо час останньої зміни швидкості
  ss -= 5;       // Зменшуємо поточну швидкість на невелике значення для плавного сповільнення
  // Якщо досягли або стали менше за задану швидкість, встановлюємо точне задане значення
  if (ss <= sp)
    motor.write(sp);
  else
    // Інакше, записуємо проміжне значення швидкості
    motor.write(ss);
}

 // Захист від втрати сигналу керування
  if (r == 1 && !mo) { // Перевіряємо, чи система знаходиться в режимі керування пультом (r == 1)
                       // і режим постійного руху вимкнено (!mo)
    // Якщо поточна швидкість мотора не є нейтральною (90) і з моменту отримання
    // останньої команди (ts1) пройшло більше 250 мілісекунд (можлива втрата сигналу)
    if (motor.read() != 90 && millis() - ts1 > 250) {
      tsp = millis() + 40; // Встановлюємо час для початку сповільнення мотора (через 40 мс)
      sp = 90;             // Задаємо нейтральну швидкість (зупинку) як цільову
                             // Це змусить мотор плавно зупинитися, якщо сигнал від пульта втрачено
    }
  }
 

  if (r == 2) { // Якщо система знаходиться в інтервальному режимі роботи (r == 2)
  if (mo && motor.read() == 90 && sp == 90 && hl == 0) {
    // Якщо увімкнено режим постійного руху (mo == true), мотор знаходиться в нейтральному положенні (90),
    // задана швидкість також нейтральна (90) і час початку кроку (hl) не встановлено (дорівнює 0)
    hl = millis(); // Запам'ятовуємо поточний час як час початку інтервалу руху
  }
  // Перевіряємо, чи минув час руху в інтервалі (hlm) або вимкнено режим постійного руху (!mo)
  if (((/*pulses*/ millis() - tms) >= hlm || !mo)) { // Коментар /*pulses*/ може бути застарілим або потребує уточнення
    // Якщо мотор не знаходиться в нейтральному положенні (90)
    if (motor.read() != 90) {
      tsp = millis() + 40; // Встановлюємо час для початку сповільнення мотора (через 40 мс)
      sp = 90;             // Задаємо нейтральну швидкість (зупинку) як цільову
    }
  }
  // Якщо час початку кроку (hl) встановлено (інтервал руху розпочато)
  if (hl > 0)
    // Перевіряємо, чи минув час зупинки в інтервалі (hld) і чи увімкнено режим постійного руху (mo)
    if (millis() - hl >= hld && mo)
    {

      // Якщо поточна команда (com) знаходиться в діапазоні 3-6 (команди руху)
      if (com > 2 && com < 7) 
      {
        hl = 0;      // Скидаємо час початку кроку для наступного інтервалу
        tms = millis(); // Оновлюємо час останньої зміни інтервалу
        // Змінюємо команду для чергування напрямків руху
        if (com == 5) com = 6;
        else if (com == 6) com = 5;
      }

      // Виконуємо дію залежно від поточної команди (com)
      switch (com) 
      {
        case 3: // Команда "вперед"
          // Якщо натиснуто кінцевий вимикач PA1 і напрямок руху - вперед (ls == true), виходимо з обробки команди
          if (digitalRead(PA1) == LOW && ls) break;
          tsp = millis(); // Запам'ятовуємо час останньої зміни швидкості
          val = map(sp1 + 2, 0, 99, 90, 180); // Перетворюємо значення швидкості (sp1) в діапазон швидкостей мотора для руху вперед
          sp = constrain(val, 90, 180);       // Обмежуємо значення швидкості в допустимому діапазоні для руху вперед
          break;
        case 4: // Команда "назад"
          // Якщо натиснуто кінцевий вимикач PA0 і напрямок руху - вперед (ls == true), виходимо з обробки команди
          if (digitalRead(PA0) == LOW && ls) break;
          tsp = millis(); // Запам'ятовуємо час останньої зміни швидкості
          val = map(99 - sp1, 0, 99, 0, 90);   // Перетворюємо значення швидкості (sp1) в діапазон швидкостей мотора для руху назад
          sp = constrain(val, 0, 90);         // Обмежуємо значення швидкості в допустимому діапазоні для руху назад
          break;

        case 5: // Команда "вперед" 
          // Якщо натиснуто кінцевий вимикач PA1 і напрямок руху - вперед (ls == true), виходимо з обробки команди
          if (digitalRead(PA1) == LOW && ls) break;
          tsp = millis(); // Запам'ятовуємо час останньої зміни швидкості
          val = map(sp1 + 2, 0, 99, 90, 180); // Перетворюємо значення швидкості (sp1) в діапазон швидкостей мотора для руху вперед
          sp = constrain(val, 90, 180);       // Обмежуємо значення швидкості в допустимому діапазоні для руху вперед

          break;
        case 6: // Команда "назад" 
          // Якщо натиснуто кінцевий вимикач PA0 і напрямок руху - вперед (ls == true), виходимо з обробки команди
          if (digitalRead(PA0) == LOW && ls) break;
          tsp = millis(); // Запам'ятовуємо час останньої зміни швидкості
          val = map(99 - sp1, 0, 99, 0, 90);   // Перетворюємо значення швидкості (sp1) в діапазон швидкостей мотора для руху назад
          sp = constrain(val, 0, 90);         // Обмежуємо значення швидкості в допустимому діапазоні для руху назад
          break;
       }
     }
   }


  // Отримуємо повідомлення від пульта керування через модуль SX1278 (LoRa)
  // Очищаємо рядок 's', щоб підготувати його для зберігання нового вхідного повідомлення
  s = "";

  // Викликаємо функцію 'onReceive' для обробки отриманого LoRa пакета.
  // 'LoRa.parsePacket()' повертає розмір прийнятого пакета (кількість байт),
  // який передається у функцію 'onReceive' як аргумент 'packetSize'.
  onReceive(LoRa.parsePacket());

  // Отримуємо повідомлення від мобільного додатку через Bluetooth модуль
  // Обробка події надходження даних на послідовний порт Serial1 від Bluetooth модуля
  serial1Event();
  // Перевіряємо, чи встановлено прапорець 'stringComplete', що сигналізує про отримання повного повідомлення
  if (stringComplete)
  { 
    if (s.length() != 18 && inputString.length() == 18)
     s=inputString;
    // Якщо повне повідомлення отримано, очищаємо рядок 'inputString'
    // для підготовки до отримання наступних даних
    inputString = "";
    // Скидаємо прапорець 'stringComplete' у стан 'false', щоб очікувати надходження
    // наступного повного повідомлення від Bluetooth
    stringComplete = false;
   }

   // Перевіряємо, чи довжина отриманого рядка повідомлення 's' дорівнює 18 символам
  if (s.length() == 18) {
    // Визначаємо режим роботи системи (r) з 2-го та 3-го символів повідомлення
    r = stod(2, 2); // Функція stod перетворює підрядок в ціле число
    // Визначаємо номер керуючої команди (com) з 4-го, 5-го та 6-го символів повідомлення
    com = stod(4, 3);
  }

// Режим керування системою
if (r == 1 || r == 2) { // Перевіряємо, чи система знаходиться в режимі ручного керування (r == 1)
                         // або в інтервальному режимі (r == 2)
  // Отримуємо значення швидкості мотора з отриманого повідомлення
  sp1 = stod(7, 1) * 10 + stod(8, 1); // Розбираємо два символи швидкості
  // Визначаємо режим постійного руху (mo) на основі дев'ятого символу повідомлення
  if (stod(9, 1) == 1) mo = true;
  else if (stod(9, 1) == 0) mo = false; // Режим постійного руху (true) або керування кнопкою (false)
  // Визначаємо напрямок руху (ls) на основі сімнадцятого символу повідомлення
  if (stod(17, 1) == 1) ls = true;   // Вперед
  else if (stod(17, 1) == 0) ls = false; // Назад

  // Якщо система знаходиться в інтервальному режимі (r == 2)
  if (r == 2) {
    hlm = stod(10, 4) * 1000; // Отримуємо тривалість руху в мілісекундах з символів 10-13
    hld = stod(14, 3) * 1000; // Отримуємо тривалість зупинки в мілісекундах з символів 14-16

    hl = 0; // Скидаємо час початку поточного кроку інтервалу
    // Обробка команд, специфічних для інтервального режиму
    switch (com) {
      case 2: // Команда моментальної зупинки системи
        digitalWrite(PB12, HIGH); // Вмикаємо індикатор 
        delay(1000);             // Затримка в 1 секунду
        sp = 90;                 // Встановлюємо нульову швидкість
        motor.write(90);         // Зупиняємо мотор
        digitalWrite(PB12, LOW);  // Вимикаємо індикатор
        break;
      case 1: // Команда плавної зупинки системи
        tsp = millis() + 40; // Заплановуємо початок сповільнення через 40 мс
        sp = 90;             // Задаємо нульову швидкість як цільову
        break;
    }
  }
  // Виконуємо команду, отриману від пульта керування (якщо система в ручному режимі)
  if (r == 1) {
    switch (com) {
      case 0: // Команда підтримки поточної швидкості
        ss = motor.read(); // Зчитуємо поточну швидкість мотора
        // Якщо поточна швидкість більша за нейтральну, плавно розганяємо в напрямку вперед
        if (ss - 90 > 0) {
          tsp = millis();
          val = map(sp1 + 2, 0, 99, 90, 180);
          sp = constrain(val, 90, 180);
        } else if (ss - 90 < 0) { // Якщо поточна швидкість менша за нейтральну, плавно розганяємо в напрямку назад
          tsp = millis();
          val = map(99 - sp1, 0, 99, 0, 90);
          sp = constrain(val, 0, 90);
        }
        break;
      case 2: // Команда моментальної зупинки системи
        digitalWrite(PB12, HIGH); // Вмикаємо індикатор
        delay(1000);
        sp = 90;
        motor.write(90);
        digitalWrite(PB12, LOW); // Вимикаємо індикатор
        break;
      case 1: // Команда плавної зупинки системи
        tsp = millis() + 40;
        sp = 90;
        break;
      case 3: // Команда руху вперед
        // Якщо натиснуто кінцевий вимикач PA1 і напрямок руху - вперед, ігноруємо команду
        if (digitalRead(PA1) == LOW && ls) break;
        ts1 = millis(); // Запам'ятовуємо час отримання команди
        tsp = ts1;     // Оновлюємо час для розгону
        val = map(sp1 + 2, 0, 99, 90, 180);
        sp = constrain(val, 90, 180); // Обмежуємо швидкість для руху вперед
        break;

      case 4: // Команда руху назад
        // Якщо натиснуто кінцевий вимикач PA0 і напрямок руху - вперед, ігноруємо команду
        if (digitalRead(PA0) == LOW && ls) break;
        ts1 = millis(); // Запам'ятовуємо час отримання команди
        tsp = ts1;     // Оновлюємо час для розгону
        val = map(99 - sp1, 0, 99, 0, 90);
        sp = constrain(val, 0, 90);   // Обмежуємо швидкість для руху назад
        break;

      case 7: // Команда негайного руху вперед
        // Якщо натиснуто кінцевий вимикач PA1 і напрямок руху - вперед, ігноруємо команду
        if (digitalRead(PA1) == LOW && ls) break;
        ts1 = millis();
        val = map(sp1 + 2, 0, 99, 90, 180);
        sp = constrain(val, 90, 180); // Обмежуємо швидкість для руху вперед
        motor.write(sp);             // Негайно встановлюємо швидкість мотора
        break; //вперед
      case 8: // Команда негайного руху назад
        // Якщо натиснуто кінцевий вимикач PA0 і напрямок руху - вперед, ігноруємо команду
        if (digitalRead(PA0) == LOW && ls) break;
        ts1 = millis(); /*tm1=tm;*/
        val = map(99 - sp1, 0, 99, 0, 90);
        sp = constrain(val, 0, 90);   // Обмежуємо швидкість для руху назад
        motor.write(sp);             // Негайно встановлюємо швидкість мотора
        break; //назад
     }
   }
  }
 
}

// Обробка вхідних повідомлень від модуля SX1278 (LoRa)
void onReceive(int packetSize) {
  if (packetSize == 0) return; // Якщо розмір пакета нульовий, виходимо з функції (немає даних для обробки)

  // Ініціалізуємо рядок для зберігання отриманого повідомлення
  s = "";

  // Читаємо байти з прийнятого LoRa пакета до тих пір, поки вони доступні
  while (LoRa.available()) {
    // Зчитуємо один байт та перетворюємо його на символ, додаючи до рядка 's'
    s += (char)LoRa.read();
  }
  // Після завершення циклу рядок 's' міститиме повне отримане повідомлення
}

// Відправка текстового повідомлення через модуль SX1278 (LoRa)
void sendMessage(String outgoing) {
  LoRa.beginPacket();     // Початок формування нового LoRa пакета
  LoRa.print(outgoing);   // Додавання текстового повідомлення до пакета
  LoRa.endPacket();       // Завершення формування пакета та його відправка
}

// Обробник події надходження даних на послідовний порт Serial1 від Bluetooth
void serial1Event() {
  // Виконуємо цикл до тих пір, поки на послідовному порту Serial1 є доступні байти для читання
  while (Serial1.available()) {
    // Зчитуємо один новий байт з послідовного порту Serial1 та перетворюємо його на символ
    char inChar = (char)Serial1.read();
    // Додаємо прочитаний символ до рядка 'inputString', який, ймовірно, використовується
    // для накопичення повного повідомлення, що надходить через Serial1
    inputString += inChar;
    // Перевіряємо, чи є прочитаний символ символом нового рядка ('\n').
    // Символ нового рядка часто використовується як індикатор кінця повідомлення.
    if (inChar == '\n') {
      // Якщо отримано символ нового рядка, встановлюємо логічний прапорець 'stringComplete' в 'true'.
      // Це сигналізує основному циклу програми (loop()), що повне повідомлення було отримано
      // і готове до подальшої обробки.
      stringComplete = true;
    }
  }
}